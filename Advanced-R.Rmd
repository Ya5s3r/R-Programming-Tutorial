---
title: "Advanced-R"
author: "Yasser"
date: "`r Sys.Date()`"
output: html_document
---

# Advanced R

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
getwd()
```

## Names and values

**The distinction between names and values, and when R will copy an object.**

Question 1

Given the following data frame, how do I create a new column called “3” that contains the sum of 1 and 2? You may only use $, not [[. What makes 1, 2, and 3 challenging as variable names?

```{r}
df <- data.frame(runif(3), runif(3))
names(df) <- c(1,2)
df
df$`3` <- df$`1` + df$`2` # needs the backticks to work 

df
```


```{r}
# We’ll use the lobstr package to dig into the internal representation of R objects.
#install.packages("lobstr")
library(lobstr)
```

### Binding basics

Consider the code:

```{r}
x <- c(1, 2, 3)
```

Accurate to say:

It’s creating an object, a vector of values, c(1, 2, 3).
And it’s binding that object to a name, x.

The object, or value, doesn’t have a name; it’s actually the name that has a value.

The name binds or references a value, which here is the vector.

Think of a name as a reference to a value. For example the code below doesn't create another copy of c(1, 2, 3), you actually get another binding to the existing object:

```{r}
y <- x
```


You can access an object’s identifier with lobstr::obj_addr(). Doing so allows you to see that both x and y point to the same identifier:

```{r}
obj_addr(x)

obj_addr(y)
# they have the same identifier - which indicates where in memory the value is stored.
```
These identifiers are long, and change every time you restart R.

**It can take some time to get your head around the distinction between names and values, but understanding this is really helpful in functional programming where functions can have different names in different contexts.**

### Non-syntactic names

R has rules around what constitutes a valid name. A **syntactic** name must consist of letters, digits, `.` and `_` but can't begin with `_` or a digit. In addition you can't use any of the reserved words like `TRUE`, `NULL`, `if` and `function`. There is a complete list (`?Reserved`). A name that doesn't follow these rules is non-syntactic and will cause an error:

```{r}
_abc <- 1
```

```{r}
if <- 10
```

It is possible to use any name by using backticks:

```{r}
`_abc` <- 1
`_abc`
`if` <- 10
`if`
```
Such instances may occur when loading data created outside of R.

**You can also create non-syntactic bindings using single or double quotes (e.g. "_abc" <- 1) instead of backticks, but you shouldn’t, because you’ll have to use a different syntax to retrieve the values. The ability to use strings on the left hand side of the assignment arrow is an historical artefact, used before R supported backticks.**

#### Exercises

1. Explain the relationship between a, b, c and d in the following code:

```{r}
a <- 1:10
b <- a
c <- b
d <- 1:10
```


```{r}
obj_addr(a)
obj_addr(b)
obj_addr(c)
obj_addr(d)

# a, b and c are all the same - they are referencing the same object, as confirmed by the objects address
# d has created a new object, confirmed by the different object address
```

2. The following code accesses the mean function in multiple ways. Do they all point to the same underlying function object? Verify this with lobstr::obj_addr().

```{r}
mean
base::mean
get("mean")
evalq(mean)
match.fun("mean")

# all the above point to the same underlying function, as confirmed by the the address associated with each (bytecode below)
# They are also all in the same environment
```

3. base R data import functions, like read.csv(), will automatically convert non-syntactic names to syntactic ones. Why might this be problematic? What option allows you to suppress this behaviour?

```{r}
?read.csv
# the check.names argument:
# logical. If TRUE then the names of the variables in the data frame are checked to ensure that they are syntactically valid variable names. If necessary they are adjusted (by make.names) so that they are, and also to ensure that there are no duplicates.
# this could be an problem if it resulsts in information about the variable being lost.
```

4. What rules does make.names() use to convert non-syntactic names into syntactic ones?

```{r}
?make.names
# A syntactically valid name consists of letters, numbers and the dot or underline characters and starts with a letter or the dot not followed by a number. Names such as ".2way" are not valid, and neither are the reserved words.
# 
# The definition of a letter depends on the current locale, but only ASCII digits are considered to be digits.
# 
# The character "X" is prepended if necessary. All invalid characters are translated to ".". A missing value is translated to "NA". Names which match R keywords have a dot appended to them. Duplicated values are altered by make.unique.
```

5. Why is .123e1 not a syntactic name? -- as above

### Copy on modify

Consider the following code. It binds x and y to the same underlying value, then modifies y

```{r}
x <- c(1, 2, 3)
y <- x

y[[3]] <- 4
print(x)

print(y)
```

Modifying y clearly didn’t modify x. So what happened to the shared binding? While the value associated with y changed, the original object did not. Instead, R created a new object, 0xcd2, a copy of 0x74b with one value changed, then rebound y to that object.

This is referred to as **copy-on-modify**. **Understanding this concept significantly improves understanding the performance of R code.** With copy on modify you get different results in R Studio, as the environment pane makes a reference to each object to display information about it. For experimentation here it was therefore suggested to use R Markdown or the terminal.

#### tracemem()

You can see when an object gets copied with the help of base::tracemem(). Once you call that function with an object, you’ll get the object’s current address:

```{r}
x <- c(1, 2, 3)
cat(tracemem(x), "\n")

```
Now, whenever the object is copied, `tracemem()` will print a message telling you which object was copied, its new address, and the sequence of calls that led to the copy:

```{r}
y <- x
y[[3]] <- 4L
```
If we modify y again, it doesn't get copied. This is as the new object now only has a single name bound to it, so R applies **modify-in-place optimisation.**

```{r}
y[[3]] <- 5L

# untracemem() turns tracing off:
untracemem(x)
```


```{r}
original <- c(10, 20, 30, 40, 50)
cat(tracemem(original), "\n")

copy <- original
copy[[5]] <- 100


```
```{r}
copy
copy[[5]] <- 200
untracemem(copy)
```


#### Function calls

The same rules for copying also apply to function calls. Take this code:

```{r}
f <- function(a) {
  a
}

x <- c(1, 2, 3)
cat(tracemem(x), "\n")

z <- f(x)
# there is no copy here

untracemem(x)
```

While f() is running, the a inside the function points to the same value as the x does outside the function.

Once f() completes, x and z point to the same object. The object (the value) never gets copied because it never gets modified. If f() did modify x, R would create a new copy, and then z would bind that object.

#### Lists
